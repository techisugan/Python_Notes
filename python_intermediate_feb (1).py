# -*- coding: utf-8 -*-
"""Python Intermediate_Feb.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OTG8Q_EY1pZY9aIQn2NZz1WktMAQnOlS
"""

#Introduction OOP
#Class & object
#Attribute
#Constructor
#Decorator/closure
#Inheritance
#Polymorphism
#File  Handing
#Expection Handling
#Regular Expression

#POP
#Constructed using Procedure/Function
#Example: C,COBOL
#why?
        #Data security
        #Computer( Monitor, CPU(RAM,Bus,HHD...etc),keywordboard)
        #Data are kept global

#OOP:
#Constructed using class & object
#Example: Java,C++,C#,Python
#why?
        #computer,CPU
        #high Data Security
#when?
        #1960-"Alan kay"

#4Pillars OOP:
        #1.Encapsulation
        #2.Abstraction
        #3.polymorphism
        #4.Inheritance

#Abstraction:
        #Providing only necessary information
        #Ex: CPU-on/off , ATM

#Encapsulation:
        #combining/binding  information(method/attribute) into single unit
        #Ex:Capsule,class

#Inheritance:
        #when one class property is acquired by another class
        #gives=>base,super
        #gets=>derived,sub
        #Relationship: "Is-a"
        #example:
                    #Employee -person
                    #Doctor-surgeon

#Association:
            #Composition(fully dependent)
            #Aggregation (Partially dependent)
                    #father-child  ("has-a")
                    #college-student
                    #person -DOB
                    #Bank -customer

#Polymorphism:
            #One entity existing in different forms
            #Run time:Overriding

#Overloading
#compile time:
                        #Python :No FunctionOverloading,No Constructor

#2bases:
#1.class
            #collection of attribute & method(common behaviour & functinality)
            #its a blue print /template
            #memory allocation: no
            #Ex: Furniture,laptop,pen,car,emp

#2.object
            #instance/part of calss
            #memory allocation:yes
            #Ex: laptop: HP,DELL,...etc

#Syntax:
class className:
    #class member
    #attribute(variable)
    #method(function)

objectName=className()

class Sample:
    pass

obj=Sample()
print(obj)

#Method:
        #Class method
        #Instance method

def mymethod():
    #statement-1

#Class method
#method access:class name

class Sample:
    var="Sample attribute"  #Class Attribute
    def mymethod(self):            #Class method
        print("Happy Learning...!")
        print("All is well.......!")

    def mymethod():
        print("Demo...!")

Sample.mymethod()
print(Sample.var)

#self:
        #variable name
        #used to refer the current calling object

#C++/Java:
        #"this" keyword

#Instance method
#Access: object
class Sample:
    def mymethod(self):                           #Instance
        print("Happy Learning...!")
        print("All is well.......!")
        print(self)

obj=Sample()
print(obj)
obj.mymethod()                                   #mymethod(obj)
#Sample.mymethod()

def disp(name):
    print("Hi")

disp("Ram")

#Attribute:
        #class Attribute
        #Static Attribute
        #Instance Attribute
        #Local Attribute
        #Global Attribute

#class  Attribute:
            #Where:Declared inside the class
            #Access: Class name
            #Scope:Class scope
            #Memory:shared memory accross all instance

class Student:
    studName="Sam"    #class attribute
    studId=9876
    def get(self):
        print("Student Name-get:",Student.studName)
        print("Student Id-get:",Student.studId)

    def put(self):
        print("Student Name-Put:",Student.studName)
        print("Student Id-Put:",Student.studId)

stud=Student()
stud.get()
stud.put()
print("Student Name:",Student.studName)
print("Student Id:",Student.studId)

class Student:
    studName="Sam"    #class attribute               @2000=>studName-->"Sam"
    studId=100                                                           #@2008=>StudId ----->"100"

    def  idGenerate(self):
        Student.studId=Student.studId+1            #2008-->101  102  103

    def display(self):
        print("Student Id:",Student.studId)

stud1=Student()
stud1.idGenerate()
stud1.display()               #o/p:101           100                101

stud2=Student()
stud2.idGenerate()
stud2.display()             #o/p:102             100                 101

stud3=Student()
stud3.idGenerate()
stud3.display()           #o/p:103                100                  101

#Instance Attribute:
        #where:Declared instance the method
        #Access: Instance name
        #scope:Instance Scope
        #Memory: unique for each instance

#Sum of 2nos
class Addition:
    def get(self):
        self.no1=int(input("Enter no1:"))   #instance attribute:
        self.no2=int(input("Enter no2:"))

    def sumofnos(self):
        self.sum=self.no1+self.no2

    def display(self):              #self=add1    self=add2    display(abc):
        print("Sum:",self.sum)

add1=Addition()         #add1= no1=10  no2=5
add1.get()
add1.sumofnos()    #sumofnos(add1)   ->sum=15

add2=Addition()            #add2=no1=20   no2=5
add2.get()
add2.sumofnos()    #sumofnos(add2)  -->sum=25

add1.display()          #display(add1)
add2.display()          #display(add2)

print("Sum-add1:",add1.sum)
print("Sum-add2:",add2.sum)

#Local Attribute:
        #where: declared the block/method
        #access: name
        #Scope: method/block
        #Memory:block

class Student:
    def get(self):
        studName=input("Enter Student Name:")   #Local
        studId=int(input("Enter Student Id:"))
        print("Student Name-get:",studName)
        print("Student Id-get:",studId)

    def put(self):
        print("Student Name-Put:",studName)
        print("Student Id-Put:",studId)

stud=Student()
stud.get()
stud.put()
#print("Student Name:",Student.studName)
#print("Student Id:",Student.studId)

1#Global Attribute:
            #where:Decalred outside the class
            #Access: name
            #Scope:global

m

var="Student -information"   #Global
class Student:

    def get(self):
        var="Student Record"    #Local  (new copy of memory)
        studName=input("Enter Student Name:")   #Local
        studId=int(input("Enter Student Id:"))
        print("Student Name-get:",studName)
        print("Student Id-get:",studId)
        print("Var-Global :",var)    #Student -Record

    def put(self):
        print("Var-Global :",var)  #Student -information"


stud=Student()
stud.get()
stud.put()
print("Var-Global :",var)   #Student -information"

var="Student -information"   #Global
class Student:

    def get(self):
        global var    #use global
        var="Student Record"    #use global -rename
        studName=input("Enter Student Name:")   #Local
        studId=int(input("Enter Student Id:"))
        print("Student Name-get:",studName)
        print("Student Id-get:",studId)
        print("Var-Global :",var)    #Student -Record

    def put(self):
        print("Var-Global :",var)  #Student -information"


stud=Student()
print("Before Get Var-Global :",var)
stud.get()
stud.put()
print("Var-Global :",var)   #Student -information"

#Recap:
            #OOP
            #class & Object
            #Method-class ,Instance
            #Attribute-Class/Static,Instance,Local,Global

#Constructor:
        #is a special method
        #initalize the object/invoked automatically once object is created
        #__init__()
        #Why?
                #set the inital state of the object by assigning values to the the attributes
        #Overloading:No
                                #same method name difference in function signature/argument

class Sample:
    def __init__(self):
        print("Constructor")

    def display(self):
        print("Hi")

obj=Sample()
obj.display()

class Sample:
    def __init__(self):                    #default
        print("Constructor")

    def __init__(self,var):                  #Over-Writes
        print("Constructor",var)

    def display(self):
        print("Hi")

obj=Sample("Hi")   #obj=Sample()
obj.display()

class Sample:
    def __init__(self):
        print("Constructor")

    def __init__(self,var):
        print("Constructor", var)



obj=Sample()

class Student:
    #def get(self):
    def __init__(self):
        self.studName=input("Enter Student Name:")
        self.studId=int(input("Enter Student Id:"))
        self.grade=input("Enter Grade:")

    def display(self):
        print("Student Name:",self.studName)
        print("Student Id:",self.studId)
        print("Grade:",self.grade)

stud=Student()
#stud.get()
stud.display()

# del object
# __del__

class Student:
    #def get(self):
    def __init__(self):
        self.studName=input("Enter Student Name:")
        self.studId=int(input("Enter Student Id:"))
        self.grade=input("Enter Grade:")

    def display(self):
        print("Student Name:",self.studName)
        print("Student Id:",self.studId)
        print("Grade:",self.grade)

    def __del__(self):
        print(f'Deleted Object of :{type(self)}')   #type()

stud=Student()
#stud.get()
stud.display()
del stud
#stud.display()

#String
#return string type:
#__str__()

#Typecasting
no=200
print(type(no))
print(type(str(no)))


print(type(int.__str__(no)))


#Display object information

class Student:
    #def get(self):
    def __init__(self):
        self.studName=input("Enter Student Name:")
        self.studId=int(input("Enter Student Id:"))
        self.grade=input("Enter Grade:")

    def display(self):
        print("Student Name:",self.studName)
        print("Student Id:",self.studId)
        print("Grade:",self.grade)

    def __str__(self):  #default return type-string
        return f'STR-Display Student Information of {self.studName}'

    def __repr__(self):  #default return type-string
        return f'REPR-Display Student Information of {self.studName}'

    def __del__(self):
        print(f'Deleted Object of :{type(self)}')   #type()

stud=Student()
#stud.get()
stud.display()
print(stud)          #<__main__.Student object at 0x7d78a5693d90>
print(repr(stud))
del stud

#__dict__
stud=Student()
print(stud.__dict__)

#str=> return string(human -readable format)
        #=>display
#repr=>return string(object)
        #=>debugging & development
        #=>complete info about the object


import datetime
tday=datetime.datetime.now()

print(str(tday))
print(repr(tday))

print?

#Dunder attribute:
#__name__   :return  name of current  executing file
#__dict__       :Display object  information
#__doc__       :Document Our code

class Student:
    """This is  an Example of Student Class"""

    def __init__(self,studName,studId,grade):
        """        Intitalizes a new student object
        :param studName: Student Name
        :param studId: Student Id
        :param grade: Student Grade
        """
        self.studName=studName
        self.studId=studId
        self.grade=grade

    def display(self):
        """
        Display Student Information
        :return: None
        """
        print("Student Name:",self.studName)
        print("Student Id:",self.studId)
        print("Grade:",self.grade)

    def __str__(self):  #default return type-string
        return f'STR-Display Student Information of {self.studName}'

    def __repr__(self):  #default return type-string
        return f'REPR-Display Student Information of {self.studName}'

    def __del__(self):
        print(f'Deleted Object of :{type(self)}')   #type()

stud=Student("Ram",101,"A")
stud.display()
print(stud)          #<__main__.Student object at 0x7d78a5693d90>
print(repr(stud))

print(stud.__doc__)
print(stud.__init__.__doc__)
print(stud.display.__doc__)

#del stud

#Decorator:
        #First class function
        #closure
        #Decorator

#First class Function:
#Passing function as a parameter for another function

def add(no1,no2):
    return no1+no2

def prod(no1,no2):
    return no1,no2

no1=int(input("Enter No1:"))
no2=int(input("Enter No2:"))
print(add(no1,no2))
print(prod(no1,no2))

#Power of add,prod
def expo(myfun):    #myfun-add
    return myfun(2,3)**2

def add(no1,no2):
    return no1+no2

def prod(no1,no2):
    return no1*no2

print("Power of sum:",expo(add))
print("Power of expo:",expo(prod))

#closure:
        #How : Nested Function
        #Technique: where our function holds the value of inner function even after going out of scope

        #step:
                #1.Declare an outer function
                #2.outer function must take only one argument
                #3.Declare the inner function (write logic)
                #4.Inner function  should return the result
                #5.outer function must return inner function

def expo(myfun):              #2 myfun-add                                   myfun-prod
    def inner(n1,n2):                         #6  *args
        return myfun(n1,n2)**2       #7   #10  res**2
    return inner                                  #3

def add(no1,no2):               #8
    return no1+no2                 #9 return res

def prod(no1,no2):
    return no1*no2



no1=int(input("Enter No1:"))
no2=int(input("Enter No2:"))
closFun1=expo(add)                              #1   4     closFun1=inner
print("Power of sum:",closFun1(no1,no2))  #5

closFun2=expo(prod)                              #1   4     closFun1=inner
print("Power of sum:",closFun2(no1,no2))

def Greeting(name1,name2):
    return f"Heartly Welcoming you......!{name1} and {name2}"

name1=input("Enter Name:")
name2=input("Enter Name:")
print(Greeting(name1,name2))

#HEARTLY WELCOMING YOU ROB AND BOB

var=1,2,3,4
print(var)

def  caps(myfun):
    def inner(name1,name2):                                    #def inner(*args):  args= tuple
        return myfun(name1,name2).upper()
    return  inner

def Greeting(name1,name2):
    return f"Heartly Welcoming you......!{name1} and {name2}"

name1=input("Enter Name:")
name2=input("Enter Name:")
closFun=caps(Greeting)
print(closFun(name1,name2))

#Decorator:
#@

#step:
                #1.Declare an outer function is called decorator
                #2.outer function must take only one argument
                #3.Declare the inner function (write logic)
                #4.Inner function  should return the result
                #5.outer function must return inner function

def expo(myfun):
    def inner(n1,n2):
        return myfun(n1,n2)**2
    return inner

@expo
def add(no1,no2):
    return no1+no2

@expo
def prod(no1,no2):
    return no1*no2

no1=int(input("Enter No1:"))
no2=int(input("Enter No2:"))
print(add(no1,no2))
print(prod(no1,no2))

def  caps(myfun):
    def inner(name1,name2):                                    #def inner(*args):  args= tuple
        return myfun(name1,name2).upper()
    return  inner

@caps
def Greeting(name1,name2):
    return f"Heartly Welcoming you......!{name1} and {name2}"

name1=input("Enter Name:")
name2=input("Enter Name:")
print(Greeting(name1,name2))

#Access Specifier:
#Defines accessblity of  method,attribute
#Types:
            #public :
            #private: __
            #protected -no (_)

class Employee:
    def __init__(self,fname,lname,sal):
        self.fname=fname              #Instance Attribute (Public)
        self.lname=lname
        self.sal=sal

    def display(self):                     #method-init,display  (Public)
        print("Fname:",self.fname)
        print("Lname:",self.lname)
        print("Sal:",self.sal)

emp=Employee("Ram","Kumar",10000)
emp.display()
print("EmpName:",emp.fname)

class Employee:
    def __init__(self,fname,lname,sal):
        self.__fname=fname              #Instance Attribute (Private)
        self.__lname=lname
        self.__sal=sal

    def  __display(self):                     #method-init,display  (Public)
        print("Fname:",self.__fname)
        print("Lname:",self.__lname)
        print("Sal:",self.__sal)

    def get(self):
        self.__display()

emp=Employee("Ram","Kumar",10000)
#emp.__display()
emp.get()
#print("EmpName:",emp.__fname)

#Private element of class (attribute/method) -->public method

class myclass:
    def _priv1(self):
        pass

    def __priv2(self):
        self.__priv1
        pass

class Employee:
    def __init__(self,fname,lname,sal):
        self._fname=fname              #Instance Attribute (Public)
        self.lname=lname
        self.sal=sal

    def display(self):                     #method-init,display  (Public)
        print("Fname:",self._fname)
        print("Lname:",self.lname)
        print("Sal:",self.sal)

emp=Employee("Ram","Kumar",10000)
emp.display()
print("EmpName:",emp._fname)

#Recap:
        #Constructor: __init__()
        #Dunder /Magic method : __str__(),__repr__(),__del__()
        #Dunder attribute: __name,__dict,__doc
        #Decorator: frist class function,closure
        #Access specifier

#Types:
        #Static Decorator
        #class Decorartor
        #property Decorator

#Static Decorator:
        #modify the functionality with changing the source code
        #(@)static method
        #they access only class attribute
        #not bounded the any object
        #Access: similar to normal method call(explict)

class Employee:
    empId=100
    def get(self):
        self.empname="Ram"
        print("EmpId:",Employee.empId)
        print("EmpName:",self.empname)


    @staticmethod
    def mystatic():
        print("EmpId-static:",Employee.empId)
        #print("EmpName:",self.empname)

emp=Employee()
emp.get()               #get(emp)
Employee.mystatic()
emp.mystatic()   #

#classmethod:
#modify the class with changingt the source code
#can alter class structure/behaviour
#(@)class method
#they access only class attribute
# bounded to object
#Access: similar to normal method call(explict)

def add_method(cls):
    def new_method(self):
        self.name="Bob"
        return f'{self.name} say hello....!'
    cls.new_method=new_method
    return cls

@add_method
class Employee:
    def __init__(self,name):
        self.name=name

    def display(self):
        print("Display....!",self.name)

emp=Employee("Alice")
print(emp.new_method())
emp.display()
#"Alice  say hello"

class Employee:
    empId=100
    def get(self):
        self.empname="Ram"
        print("EmpId:",Employee.empId)
        print("EmpName:",self.empname)

    @classmethod
    def mycalssmethod(self):
        print("EmpId-class:",Employee.empId)
        print("EmpName:",self.empname)

    @staticmethod
    def mystatic():
        print("EmpId-static:",Employee.empId)
        #print("EmpName:",self.empname)

emp=Employee()
emp.get()               #get(emp)
emp.mycalssmethod()
Employee.mystatic()
emp.mystatic()

#Use case:
    #Static Decorator:(add function)
                #1.Input validation
                #2.Logging Function call
                #3.caching result

    #Class Decorator:(add method)
            #1.add method
            #2.singleton Pattern
            #3.class-level validation

#Property Decorator:
            #getter: allow to acces element outside the class
                        #:must return value
                        #:accessor

            #setter:allow to value for private attribute
                        #:must have parameter
                        #:Mutator

class Employee:
    def __init__(self,fname,lname,sal):
        self.__fname=fname              #Instance Attribute (Private)
        self.__lname=lname
        self.__sal=sal

    def  display(self):                     #method-init,display  (Public)
        print("Fname:",self.__fname)
        print("Lname:",self.__lname)
        print("Sal:",self.__sal)

    def fullName(self):        #getter method
        return self.__fname+" "+self.__lname

    def setFname(self,fname):  #setter method
        self.__fname=fname

emp=Employee("Ram","Kumar",10000)
emp.display()
emp.setFname("Arul")
print("FullName:",emp.fullName())
#emp.fname="Karthick"
#print("FullName:",emp.__fname+" "+emp.__lname)

class Employee:
    def __init__(self,fname,lname,sal):
        self.fname=fname              #Instance Attribute (Private)
        self.lname=lname
        self.sal=sal

    @property
    def fullName(self):        #getter method
        return self.fname+" "+self.lname

    @fullName.setter
    def fullName(self,name): #name="Robin sharma"
        self.fname,self.lname=name.split()

    @property
    def email(self):
        return self.fname+"."+self.lname+"@gmail.com"

fname="Ram"
lname="Kumar"
sal=100000
emp=Employee(fname,lname,sal)
print("Name:",emp.fullName)
print("Email:",emp.email)

#Arul Kumar
emp.fname="Arul"
print("Name:",emp.fullName)
print("Email:",emp.email)

emp.fullName="Robin sharma"               #setter
print("Name:",emp.fullName)                #getter
print("Email:",emp.email)

name="Robin sharma"
fname,lname=name.split()
print(fname,lname)

class Employee:
    def __init__(self,fname,lname,sal):
        self.__fname=fname              #Instance Attribute (Private)
        self.__lname=lname
        self.__sal=sal

    @property
    def fullName(self):        #getter method
        return self.__fname+" "+self.__lname

    @fullName.setter
    def fullName(self,name): #name="Robin sharma"
        self.__fname,self.__lname=name.split()

    @property
    def email(self):
        return self.__fname+"."+self.__lname+"@gmail.com"

fname="Ram"
lname="Kumar"
sal=100000
emp=Employee(fname,lname,sal)
print("Name:",emp.fullName)
print("Email:",emp.email)

#Arul Kumar
#emp.fname="Arul"
#print("Name:",emp.fullName)
#print("Email:",emp.email)

emp.fullName="Robin sharma"               #setter
print("Name:",emp.fullName)                #getter
print("Email:",emp.email)

#Inheritance:
        #One class access/acquire property of another class
        #Relationship: "Is-a"
        #types:
                    #single,multiple,multilevel,hierarchical,hybrid

        #Syntax:
        class Base(object):
            pass
        class Derived(Base):
            pass

        #Single Imheritane:
                    #Base-1  derived-1

#display:
        #Fullname
        #email
        #sal
        #tech

class Employee(object):
    def __init__(self):
   #def get(self):
        print("Employee init........!")
        self.__fname=input("Enter Fname:")  #Instance (self.fname-public)
        self.__lname=input("Enter Lname:")
        self.__sal=int(input("Enter Sal:"))
    def fullName(self):                  #getter
        return self.__fname+" "+self.__lname
    def email(self):
        return self.__fname+"."+self.__lname+"@gmail.com"
    def sal(self):
        return self.__sal

class Developer(Employee):   #does the private elements are inherited ? -yes /but not Access
    def __init__(self):
    #def get(self):
        print("Developer init.......!")
        super().__init__()                              #super() =immediate base class
        self.__tech=input("Enter Tech:")

    def display(self):
        print("FullName:",super().fullName())
        print("Email:",super().email())   #self.email()
        print("salary:",super().sal())
        print("Tech:",self.__tech)

Dev=Developer()     #Derived to Base
Dev.display()

#n dev
Enter Fname:Sam
Enter Lname:Edi
Enter Sal:9876543
Enter Tech:C++

Enter Fname:Ram
Enter Lname:Edi
Enter Sal:9876543
Enter Tech:C++


FullName: Sam Edi
Email: Sam.Edi@gmail.com
salary: 9876543
Tech: C++
FullName: Ram Edi
Email: Sam.Edi@gmail.com
salary: 9876543
Tech: C++

print("Happy Learning...!")

#Recap:
        #Decorator:
                    #class Decorator
                    #static Decorator
                    #property Decorator:
                                #getter
                                #setter
                    #Inheritance: Single Inheritance

class Employee(object):
    def __init__(self):
   #def get(self):
        print("Employee init........!")
        self.__fname=input("Enter Fname:")
        self.__lname=input("Enter Lname:")
        self.__sal=int(input("Enter Sal:"))
    def fullName(self):
        return self.__fname+" "+self.__lname
    def email(self):
        return self.__fname+"."+self.__lname+"@gmail.com"
    def sal(self):
        return self.__sal

class Developer(Employee):   #does the private elements are inherited ? -yes /but not Access
    def __init__(self):
    #def get(self):
        print("Developer init.......!")
        super().__init__()                              #super() =immediate base class
        self.__tech=input("Enter Tech:")

    def display(self):
        print("FullName:",super().fullName())
        print("Email:",super().email())   #self.email()
        print("salary:",super().sal())
        print("Tech:",self.__tech)

#Dev=Developer()     #Derived to Base
#Dev.display()

#List of object
dev=[]
n=int(input("Enter No of Developer"))
for i in range(n):  #2
    dev.append(Developer() )   #dev[0],dev[1]

#for i in range(n):
for d in dev:
    d.display()

#Multiple Inheritance:
#Base-more than one
#Derived-1

class Base1:
    pass
class Base2:
    pass
class Derived(Base1,Base2):
    pass

#Combining Features
#Modularity

class Camera:
    def __init__(self):
        print("Camera init....!")

    def capaturePhoto(self):
        return "Photo Captured....!"

class MusicPlayer:
    def __init__(self):
        print("MusicPlayer init....!")
        #super().__init__()         #excute-should call object

    def playMusic(self):
        return  "Playing Music...!"

class SmartPhone(MusicPlayer,Camera):
    def __init__(self):
        print("SmartPhone init....!")
        super().__init__()     #Immediate base-Based on how it is inherited
        Camera.__init__(self)

    def makeCall(self):
        return "Calling.....!"

sp=SmartPhone()
print(sp.makeCall())
print(sp.capaturePhoto())
print(sp.playMusic())
#GPS

#Mro:method resolution Order
print("Mro-smartPhone:",SmartPhone.__mro__)
print("Mro-MusicPlayer:",MusicPlayer.__mro__)
print("Mro-Camera:",Camera.__mro__)

#Multi-level:
class Base:
    pass

class Deri(Base):
    pass

class Derived1(Deri):
    pass

    #Hierarchical structure: level wise add
    #

class Vehicle:
    def __init__(self,brand,model,price,speed):
        self.brand=brand
        self.model=model
        self.price=price
        self.speed=speed

    def display(self):
        print("Brand:",self.brand)
        print("Model:",self.model)
        print("Price:",self.price)

class car(Vehicle):
    def __init__(self,brand,model,price,speed,color,fuel):
        #super().__init__(brand,model,price,speed)
        Vehicle.__init__(self,brand,model,price,speed)
        self.color=color
        self.fuel=fuel

    def CarDisplay(self):
        super().display()
        print("Color:",self.color)
        print("Fuel:",self.fuel)

class ElectricCar(car):
    def __init__(self,brand,model,price,speed,color,fuel,battery):
        super().__init__(brand,model,price,speed,color,fuel)
        #car.__init__(self,brand,model,price,speed,color,fuel)
        self.battery=battery

    def ElectricCarDisplay(self):
        super().CarDisplay()
        print("Battery:",self.battery)


ECar=ElectricCar("Tesla","XUV",9987654,120,"Red","Electric",100)
ECar.ElectricCarDisplay()

class Vehicle:
    def __init__(self,brand,model,price,speed):
        self.brand=brand
        self.model=model
        self.price=price
        self.speed=speed

    def display(self):
        print("Brand:",self.brand)
        print("Model:",self.model)
        print("Price:",self.price)

class car(Vehicle):
    def __init__(self,brand,model,price,speed,color,fuel):
        super().__init__(brand,model,price,speed)
        #Vehicle.__init__(self,brand,model,price,speed)
        self.color=color
        self.fuel=fuel

    def CarDisplay(self):
        super().display()
        print("Color:",self.color)
        print("Fuel:",self.fuel)

mycar=car("Tesla","XUV",9987654,120,"Red","Electric")
mycar.CarDisplay()

#Hierarchical :
#one Base- more than derived class
class Base:
    pass

class Deri1(Base):
    pass

class Deri2(Base):
    pass


#Deri1->Der1,Base
#Deri2->Der2,Base

class Employee:
    #def__init__()
    #display()
    #name,empId,baseSal
    pass

class FulltimeEmployee(Employee):
    #def__init__()
    #calculate_sal()
    #bonus
    pass

class ParttimeEmployee(Employee):
    #def__init__()
    #calculate_sal()
    #hour_rate
    #hours_word
    pass

class Intern(Employee):
    #def__init__()
    #claculate_sal()
    #stipend


Femp=FulltimeEmployee()
Pemp=ParttimeEmployee()
Iemp=Intern()

#Hybrid:
#Combination any two inheritance

#Abstraction:
            #Abstract class:
                        #Acts like a  blueprint
                        #import ABC
                        #inherit from ABC
                        #abstract base class
                        #concrete method,abstract method
                        #No object

            #Abstract method:
                        #Decorator @abstractmethod
                        #abstract "must be" implement in all its derived calss
                        #abstract:only declaration

from abc import ABC,abstractmethod
class Shape(ABC):           #square,triangle,rectangle..etc
    def  __init__(self):
        print("Shape init....!")

    def display(self):
        print("Shape Display")

    @abstractmethod
    def area():
        pass

    @abstractmethod
    def perimeter():
        pass

class Square(Shape):
    def __init__(self,side):
        super().__init__()
        self.side=side

    def area(self):   #Override
        return self.side*self.side

    def perimeter(self):
        return 4*self.side

class Circle(Shape):
    def __init__(self,radius):
        self.radius=radius

    def area(self):
        return 3.14*self.radius*self.radius

    def perimeter(self):
        return 2*3.14*self.radius


sq=Square(4)
print(sq.area())
print(sq.perimeter())
sq.display()

cir=Circle(3.4)
print(cir.area())
print(cir.perimeter())
cir.display()

class  Payment(ABC):
    #method:
    #processPayment(self,amount):
    pass

class creditCardPayment(Payment):
    #method:
    #processPayment()
                #Processing creditCardPayment of amount:digit
    pass

class PayPalPayment(Payment):
     #method:
    #processPayment()
    pass

class UPIPayment(Payment):
    #method:
    #processPayment()
    pass

#Function to choice payment type
def  make_payment(paymentMethod,mount):
    pass

from abc import ABC, abstractmethod
class Payment(ABC):
    def __init__(self, amount):
        self.amount = amount

    @abstractmethod
    def process_payment(self):
        pass

class CreditCard(Payment):
    def process_payment(self):
        print(f"Processing CreditCard payment of amount: {self.amount}")

class PayPal(Payment):
    def process_payment(self):
        print(f"Processing PayPal payment of amount: {self.amount}")

class UPIPayment(Payment):
    def process_payment(self):
        print(f"Processing UPI payment of amount: {self.amount}")

def make_payment():
    print("Select Payment Method:")
    print("1. Credit Card")
    print("2. PayPal")
    print("3. UPI Payment")

    choice = input("Enter choice (1/2/3): ")
    amount = float(input("Enter amount: "))

    if choice == '1':
        payment = CreditCard(amount)
    elif choice == '2':
        payment = PayPal(amount)
    elif choice == '3':
        payment = UPIPayment(amount)
    else:
        print("Invalid choice!")
        return

    payment.process_payment()

if __name__ == "__main__":
    make_payment()



class Base:
    # Constructor to set Data
    def __init__(self, name, roll, role):
        self.name = name
        self.roll = roll
        self.role = role

# Intermediate Class: Inherits the Base Class
class Intermediate(Base):
    def __init__(self, age, name, roll, role):
        super().__init__(name, roll, role)
        self.age = age

# Derived Class: Inherits the Intermediate Class
class Derived(Intermediate):
    def __init__(self, age, name, roll, role):
        super().__init__(age, name, roll, role)

    def Print_Data(self):
        print("The Name is", {self.name})
        print("he Age is" , {self.age})
        print("The role is" ,{self.role})
        print("quot;The Roll is" , {self.roll})

obj = Derived(21,"Admin", 25,"Software Trainer")

obj.Print_Data()

#Recap:
        #Inheritance:
        #Abstraction (Abstract method, Abstract class)

# Commented out IPython magic to ensure Python compatibility.
#Operator Overloading:
            #redefine the behaviour of the standard operators
            #magic/dunder method
            #Aithmetic operator:
                    +       __add__(self,other)
                    -       __sub__(self,other)
                    *       __mul__(self,other)
                    /       __div__(self,other)
                    //      __floordiv__(self,other)
#                     %       __mod__(self,other)
                    **      __pow__(self,other)
            #Comparison:
                    <       __lt__(self,other)
                    >       __gt__(self,other)
                    <=      __le__(self,other)
                    >=      __ge__(self,other)
                    ==      __eq__(self,other)
                    !=      __ne__(self,other)

no1=2
no2=3
print(no1+no2)
print("Hi"+ " all")
print([1,2,3]+[4,5,6])

class Arith:
        def __init__(self,no1,no2):
            self.no1=no1
            self.no2=no2

        def __add__(self,other):    #self=obj1   other=obj2
             return(self.no1+other.no1,self.no2 +other.no2)

        def __mul__(self,other):   #self=obj1 other=2
                return (self.no1*other,self.no2*other)

        def display(self):
            print("Arith  display..!")

obj1=Arith(10,20)   #no1,no2....etc
obj2=Arith(5,10)
obj1.display()             #calling object= obj1        method=display            para=no
print(obj1+obj2)        #calling object=obj1         method= __add__           para=obj2   #obj1.(+(obj2))


obj3=Arith("Hello","Happy")   #no1,no2....etc
obj4=Arith("Everyone...!","Learning")
print(obj3+obj4)


#10*2  20*2

print(obj1*2)      #calling object=obj1         method=__mul__            para=2

class Arith:
        def __init__(self,no1,no2):
            self.no1=no1
            self.no2=no2

        def __add__(self,other):    #self=obj1   other=obj2
             return  Arith(self.no1+other.no1,self.no2 +other.no2)

        def __sub__(self,other):    #self=obj1   other=obj2
             return  Arith(self.no1-other.no1,self.no2 -other.no2)

        def __str__(self):
            return "No1:{}, No2:{}".format(self.no1,self.no2)

        def display(self):
            print("Arith  display..!")

obj1=Arith(10,20)   #no1,no2....etc
obj2=Arith(5,10)
obj1.display()             #calling object= obj1        method=display            para=no
obj3=obj1+obj2
print(obj3)

obj4=obj1-obj2
print(obj4)



#Use case:
        #1.Complex computing:
                    comp1=complexNum(2,3)   #comp1=2+3i
                    comp2=complexNum(5,3)   #comp2=5+6i
                    comp3=7+9i

        #2. Cuurency object:
                    eur=curency(amount,ctype)
                  #amount=50,currect_type="EUR"
                  #Conver to EUR to USD
                  #usd=eur *?
                  #print(usd)

class Employee:
    def __init__(self,name,exp,dep):
        self.name=name
        self.exp=exp
        self.dep=dep

    def __gt__(self,other):
        return  self.exp>other.exp

    def __lt__(self,other):
        return  self.exp<other.exp

emp1=Employee("Sam",20,"HR")
emp2=Employee("Ram",5,"HR")
print("Emp1 has higher exp") if emp1>emp2  else print("Emp2 has higher exp")
print("Emp1 has less exp") if emp1<emp2  else print("Emp2 has less exp") #calling object=emp1            method= __gt__   para=emp2

dir(int)

#Exception Handling:
            #unexpected even ouccured during excution of program
            #error:
                    #Syntax Error
                    #Logical Error

#print(10/0)                       #ZeroDivisionError: division by zero
#print(int("Python"))        #ValueError: invalid literal for int() with base 10: 'Python'
if True:
print("hi")                              #IndentationError:

dir(locals()['__builtins__'])

try:
    #gaurd block
    pass

except:
    #expection handling
    pass

else:
    #will execute only when there is no exception
    pass

finally:
    #will exceute always
    pass

#Divide of 2nos
import traceback
no1=int(input("Enter No1:"))
no2=int(input("Enter No2:"))
try:
    color=['Blue','Pink','Yellow']
    print(color[6])
    val=int(input("Enter val:"))
    res=no1/no2

except ZeroDivisionError as err:
    print("Try to provide non-Zero value for denominator...!")
    print(err)
except  ValueError as err:
    print(err)
except:
    print("Error ...!")
    traceback.print_exc()
else:
    print(res)

finally:
    print("Finally block....!")

#Raise the Exception
age=int(input("Enter age:"))
try:
    if age<18:
        raise ValueError("Age should be greater than 18")

except ValueError as err:
    print(err)

else:
    print("Happy Voting....!")

finally:
    print("See you again....!")

print(ValueError.mro())

#Custom Exception
class MyException(Exception):
    pass

#voting:
#18 -75
#<18         -raise Exception(TooYoung)
#>=76       -raise Exception(TooOld)

class tooYoung(Exception):
    def __init__(self,age):
        self.age=age

    def __str__(self):
        return "Age should be greater than 18"

class tooOld(Exception):
    def __init__(self,age):
        self.age=age

    def __str__(self):
        return "Please stay home safe...!"

age=int(input("Enter age:"))
try:
    if age<18:
        raise  tooYoung(age)

    elif age>=76:
        raise  tooOld(age)

except tooYoung as err:
    print(err)

except tooOld as err:
    print(err)

else:
    print("Happy Voting....!")

finally:
    print("See you again....!")

#Recap:
    #Operator oeverloading
        #Arithmetic
        #comparison
    #Exception Handling:
        #try,except,else,finally
        #raise
        #custom Exception

#File Handling:
        #why?
                #store information pernament in disk/cloud
        #Basic operations:
                        #open
                        #write
                        #read
                        #update/delete
                        #close
        #Function:
                    #open()
                    #close()
                    #write()
                    #read(),readline(),readlines()
            #Navigation:
                    #seek() -move cursor
                    #tell()   -return the current position of cursor

#Syntax:
#open:
file descriptor=open("FileName/FilePath","Mode")
            #FileName/FilePath:
                #Absolute path: give path from root
                                        #ex: open("C:\Users\Sugan\Python\demo.py")
                #Relative path:file name
                                        #ex:open("demo.py")
          #FileMode:
                    #r    -open file for  only read
                            #currsor position:begin

                    #w  -open file for only write
                            #currsor position:begin
                            #-if file exist:truncate all the data in the file and starts from the begining.
                            #-if file does not exist: create a new file

                    #x  -Exclusive creation
                         #currsor position:begin
                         #if file does not exist: create a new filey
                         #-if file exist: throw error

                    #a-append
                            #currsor position:EOF

            #Ex: fd=open(demo)
                    #default:
                                #file:text
                                #mode:read

                    #b -binary
                    #t  -text

            #+
                    #r+ -open file for  only read/write
                    #w+
                    #a+  -write/read

                    #wb+
                    #rb+
                    #ab+

            #file descriptor.close()

fd=open("mytestfile.txt","w")
#write()
fd.write("This is an example for write operation.")
fd.write("\nSay  hello....!")
fd.close()

fd=open("mytestfile.txt","x")
#write()
for i in range(int(input("Enter N:"))):
    line=input("Enter line:")
    fd.write(line+"\n")
fd.close()

fd=open("mytestfile.txt","r")
#read()
print(fd.read())
fd.close()

fd=open("mytestfile.txt","r")
#read()
print(fd.read())
fd.close()

#readline()

fd=open("mytestfile.txt","r")
#read()
while True:
    line=fd.readline()
    print(line)
    if not line:
        break
fd.close()

#readlines()

fd=open("mytestfile.txt","r")
#read()
print(fd.readlines())
fd.close()

#Navigation:
        #tell()

fd=open("mytestfile.txt","r")
#read()
while True:
    line=fd.readline()
    print(fd.tell())
    print(line)
    if not line:
        break
fd.close()

fd=open("mytestfile.txt","r+")
#read()
while True:
    line=fd.readline()
    print(line)                   #This is file example
    print(fd.tell())            #21

    fd.write("Read")        #Writting something  to file
    fd.seek(0,0)                   #moving to begining
    if not line:
        break
fd.close()

#seek("no of bytes","Whence") #0 1

fd=open("mytestfile.txt","r+")
print(fd.tell())
fd.seek(21,0)
print(fd.tell())
fd.write("Read")
fd.seek(0,0)
print(fd.read())
fd.close()

#Attributes:
        #closed
        #mode
        #name

fd=open("mytestfile.txt","r+")
print(fd.closed)
print(fd.mode)
print(fd.name)
fd.close()
print(fd.closed)

#File with exception handling:
try:
        fd=open("mytestfile1.txt","r+")
        print("File opened successfully.....!")
except FileNotFoundError as err:
    print(err)
else:
    print(fd.read())
    print("File reading succesfull...!")
finally:
    fd.close()

#csv
#excel

fd=open("data.csv","w")
line1="123,Ram,9876543210,chn"
line2="124,Sam,9876543210,chn"
line3="125,Pram,9876543210,chn"
line4="126,Sai,9876543210,chn"

fd.write(line1+"\n")
fd.write(line2+"\n")
fd.write(line3+"\n")
fd.write(line4+"\n")
fd.close()

with open("data.csv","r") as fd:
    print(fd.read())
    print("Reading completed...!")
    print(fd.closed)
print(fd.closed)

#Regular expression:
        #parttern matching
        #Example:
                #emailID creation
                #Banking-credit card nos
                #capcha
                #find substring
                #IP Address
                #OTP
                #postal code
                #Mobile no

#print \n in output
#print("\\n")   #\n

#[rbcmsp]at
        #word=> [rat,bat,cat,sat,pat,mat]

#[^rbcm]at
        #word=> [pat,sat,tat]

#m.t


#?  0 0r 1
#*   0 or more
#+  1 or more

#name=[Sam,Sams,Samuel]
#sam?    =>Sam,Sams
#sam*    =>Sam,Sams,Samuel
#sam+   =>Sams,Samuel

\   Used to drop the special meaning of character following it

[]  Matches a characters given within the []

[^] Matches the characters except which is given within the []

^   Matches the beginning of string

$   Matches the end of string

.   Matches any character except newline

?   Matches zero or one occurrence.

|   Means OR (Matches with any of the characters separated by it)

*   Any number of occurrences (0 or more occurrences)

+   One or more occurrences

{}  Indicate number of occurrences of a preceding RE to match.
{n} exact n number
{n,m} n-min m-max

()  Enclose a group of REs

Note: To search any of these characters we must use '\' before it

\d   Matches any decimal digit, this is equivalent to the set class [0-9].

\D   Matches any non-digit character.

\s   Matches any whitespace character.

\S   Matches any non-whitespace character

\w   Matches any alphanumeric character, this is equivalent to the class [a-zA-Z0-9_].

\W   Matches any non-alphanumeric character.

\b   Matches any word with boundary (space before or its the starting)

\B   Matches any word without boundary

[0-9] Matches any number

[^0-9] Matches anything other than number between 0 and 9

[a-z] Matches any lowercase alphabet

[^a-z] Matches anything other than lowercase alphabet

[A-Z] Matches any uppercase alphabet

[^A-Z] Matches anything other than uppercase alphab

#Function:
        #compile()
        #math()

import re
mystr="Python"
pattern=re.compile("Py")
print(type(pattern))
print(pattern)

import re
mystr="Python"
pattern=re.compile("P\w*")   #create
#pattern=re.compile("Py\w*n$")  #("P....n$")
res=pattern.match(mystr)       #match
print(res)
print(res.group())

import re
mystr="Python"
res=re.match("Py\w*n$",mystr)
print(res)
#print(res.group())

#split()

mystr="This is our python Session on Regular Expression."
res=re.split(" ",mystr)
print(res)

#Findall()
import re
mystr="This is our python Session on Regular Expression.Our Session Cover fundamental  topics.This session  include OOP."
res=re.findall("Session",mystr, re.I)
#res=re.findall("Session",mystr)
print(res)

mystr="This is our python Session on Regular Expression.Our Session Cover fundamental  topics.This session  include OOP."
res=re.findall("Th",mystr,re.I)
print(res)

#mystr="Python@traing123.com"
#Fetch all alphanumeric from the given string.
#o/p:Pythontraing123com

mystr="Python@traing123.com"
print(''.join(re.findall('[a-zA-Z0-9]',mystr)))  #findall('\w+',mystr)

print(''.join(re.findall(r'\w*',mystr)))
print(re.findall(r'\w+',mystr))

mystr="Today,I reached office at 10 oclock. Tommorrow I may come by 11."
print(re.findall(r'\d+',mystr))  #\d  \w
print(re.findall(r'\d',mystr))

#search()
mystr="Today,I reached office at 10 oclock. Tommorrow I may come by 11."
#res=re.search('\d',mystr)  #1
res=re.search('at',mystr)
print(res)
print(res.group())
print(res.start())
print(res.span())

#Search for mail ID  search( ,)
mystr="Kindly reach me out at techi@sugan.com"    #word @ word . word
#res=re.search('[a-z]*@[a-z]*\.[a-z]*' ,mystr)
res=re.search('\w*@\w*\.\w*' ,mystr)
print(res)
print(res.group())

mystr="Kindly reach me out at techi@sugan.com"    #word @ word . word
#res=re.search('[a-z]*@[a-z]*\.[a-z]*' ,mystr)
res=re.search('(\w*)@(\w*)\.(\w*)' ,mystr)
print(res)
print(res.group())
print(res.group(1))
print(res.group(2))
print(res.group(3))

#sub()
mystr="Today,I reached office at 10 oclock. Tommorrow I may come by 11."
res=re.sub("\s","@",mystr)
print(res)

mystr="Today,I reached office at 10 oclock. Tommorrow I may come by 11."
res=re.sub("\s","@",mystr,2)
print(res)

# Commented out IPython magic to ensure Python compatibility.
# #Finditr()
# %%writefile  testfile.txt
# cat
# bat
# mat
# sat
# pat
# tat
#

with open('testfile.txt','r') as fd:
    print(fd.read())

#fetch all the word that ends with "at"except the word that starts with "m"
pattern=re.compile('[^m]at') #[bct]
with open('testfile.txt','r') as fd:
    content=fd.read()

matches=pattern.finditer(content)
print(matches)

for itr in matches:
    print(itr,"---->",itr.group())

# Commented out IPython magic to ensure Python compatibility.
# %%writefile data.txt
# hello, this is an quick file.
# so,I am writting something here 99.505.6666.3 and 77-304-5555-6

pattern=re.compile('\d+[.-]\d+[.-]\d+[.-]\d')

#[7-9]{2}[.-][0-9]{3}[.-][0-9]{4}[.-]\d
#pattern=re.compile('[7-9]{2}[.-][0-9]{3}[.-][0-9]{4}[.-]\d')  #{n} {10}
with open('data.txt','r') as fd:
    content=fd.read()

matches=pattern.finditer(content)
print(matches)

for itr in matches:
    print(itr,"---->",itr.group())

#First position 2 digit  and range 7,8,9
#3 digit
#4 digit
#1 digit

#customerInfo.txt

Mr.Robin
Ms.Rossy
Mr Edison
Mrs.X

#1.Fetch the name that start with Mr.  (Mr. Robin)
#2.Fetch the name that start with Mr. or space(Mr. Robin , Mr Edison)
#3.Fetch  the anme taht start with Mr. or Ms. or Mrs.

#website:
https://google.com
https://facebook.com
https:://gst.gov.in

username:
domain:
exe:  |